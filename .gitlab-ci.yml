# Official language image. Look for the different tagged releases at:
# https://hub.docker.com/r/library/docker/tags/
image: docker:latest

services:
  - docker:dind

stages:
  - build
  - test
  - package
  - deploy


# Build the wheel distribution package and upload it to the GitLab PyPi repository.
# Save the wheel package as an artifact to be used in later stage.
pypackage_build_and_upload:
  image: python:latest
  stage: build
  script:
    - pip install build twine
    - python3 -m build 
    - TWINE_PASSWORD=${CI_JOB_TOKEN} TWINE_USERNAME=gitlab-ci-token python -m twine upload --repository-url ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi ./dist/*
  artifacts:
    paths:
      - ./dist/*.whl


# Run the tests using Docker Compose.
# Uses the exit code of the integration_tests service container to determine success.
tests:
  stage: test
  script:
    - docker compose -f compose-test-runner.yaml -p ci up --exit-code-from integration_tests --build 


# Build the Docker image and push it to the GitLab Container Registry.
# The image is tagged with the project name and the version number.
# Example: registry.gitlab.com/username/project-name:1.0.0
package:
  stage: package
  script:
    # Get the app version from the VERSION.txt file.
    - APP_VERSION="$(cat VERSION.txt)"
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$APP_VERSION .
    - docker push     $CI_REGISTRY_IMAGE:$APP_VERSION


# Add deployment configuration here.
deploy:
  stage: deploy
  before_script:
    - mkdir -p ~/.ssh
    - SSH_PRIVATE_KEY=$(echo "$SSH_PRIVATE_KEY" | base64 -d)
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/production.pem
    - chmod 400 ~/.ssh/production.pem

  script:
    - APP_VERSION="$(cat VERSION.txt)"
    - echo "Production deployment started. $CI_REGISTRY_IMAGE:$APP_VERSION"
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY"
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker pull $CI_REGISTRY_IMAGE:$APP_VERSION" 
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker tag  $CI_REGISTRY_IMAGE:$APP_VERSION web_app:latest "
    - scp -i ~/.ssh/production.pem -o StrictHostKeyChecking=no ./compose.yaml $SSH_USER@$SSH_HOST:~/compose.yaml 
    # Install compose if not installed
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m) -o /usr/local/bin/docker-compose"
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "sudo chmod +x /usr/local/bin/docker-compose"
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST 'if [ ! -L /usr/bin/docker-compose ]; then sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose; fi'


    # Restart the application
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker-compose -f compose.yaml down"
    - ssh -i ~/.ssh/production.pem -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker-compose -f compose.yaml up -d"
  environment: 
    name: production
    url: http://$SSH_HOST:5000
  
  # CI/Continuous Delivery
  when: manual